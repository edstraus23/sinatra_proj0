<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>treeview.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../h2d/build_xml.html">build.xml</a>
    <li><a href="../../h2d/catalog_xml.html">catalog.xml</a>
    <li><a href="../../h2d/dtd/xhtml-lat1_ent.html">xhtml-lat1.ent</a>
    <li><a href="../../h2d/dtd/xhtml-special_ent.html">xhtml-special.ent</a>
    <li><a href="../../h2d/dtd/xhtml-symbol_ent.html">xhtml-symbol.ent</a>
    <li><a href="../../h2d/dtd/xhtml1-frameset_dtd.html">xhtml1-frameset.dtd</a>
    <li><a href="../../h2d/dtd/xhtml1-strict_dtd.html">xhtml1-strict.dtd</a>
    <li><a href="../../h2d/dtd/xhtml1-transitional_dtd.html">xhtml1-transitional.dtd</a>
    <li><a href="../../h2d/h2d_xsl.html">h2d.xsl</a>
    <li><a href="../../h2d/plugin_xml.html">plugin.xml</a>
    <li><a href="../../h2d/preprocess_xsl.html">preprocess.xsl</a>
    <li><a href="../../h2d/samples/concept_html.html">concept.html</a>
    <li><a href="../../h2d/samples/content_html.html">content.html</a>
    <li><a href="../../h2d/samples/reference_html.html">reference.html</a>
    <li><a href="../../h2d/samples/task_html.html">task.html</a>
    <li><a href="../../h2d/samples/topic_html.html">topic.html</a>
    <li><a href="../../log_txt.html">log</a>
    <li><a href="../../public/Test3_sh.html">Test3.sh</a>
    <li><a href="../../public/about_html.html">about.html</a>
    <li><a href="../../public/dtest_html.html">dtest.html</a>
    <li><a href="../../public/foo_html.html">foo.html</a>
    <li><a href="../../public/help_html.html">help.html</a>
    <li><a href="../../public/htm/Great_silly_movie_htm.html">Great_silly_movie.htm</a>
    <li><a href="../../public/htm/Movies_stepb_htm.html">Movies_stepb.htm</a>
    <li><a href="../../public/htm/athlete_htm.html">athlete.htm</a>
    <li><a href="../../public/htm/athlete_chase_htm.html">athlete_chase.htm</a>
    <li><a href="../../public/htm/athlete_jrol_htm.html">athlete_jrol.htm</a>
    <li><a href="../../public/htm/baseball_htm.html">baseball.htm</a>
    <li><a href="../../public/htm/baseball_schmidt_htm.html">baseball_schmidt.htm</a>
    <li><a href="../../public/htm/baseball_schmidt_md_htm.html">baseball_schmidt_md.htm</a>
    <li><a href="../../public/htm/bookmap_htm.html">bookmap.htm</a>
    <li><a href="../../public/htm/cm_htm.html">cm.htm</a>
    <li><a href="../../public/htm/cm_DITA_OT_htm.html">cm_DITA_OT.htm</a>
    <li><a href="../../public/htm/cm_TE_htm.html">cm_TE.htm</a>
    <li><a href="../../public/htm/cm_bookmap_html_htm.html">cm_bookmap_html.htm</a>
    <li><a href="../../public/htm/cm_create_entries_htm.html">cm_create_entries.htm</a>
    <li><a href="../../public/htm/cm_create_entries_md_htm.html">cm_create_entries_md.htm</a>
    <li><a href="../../public/htm/cm_create_entry_md_htm.html">cm_create_entry_md.htm</a>
    <li><a href="../../public/htm/cm_create_form_htm.html">cm_create_form.htm</a>
    <li><a href="../../public/htm/cm_create_map_html_htm.html">cm_create_map_html.htm</a>
    <li><a href="../../public/htm/cm_create_map_md_htm.html">cm_create_map_md.htm</a>
    <li><a href="../../public/htm/cm_create_maps_htm.html">cm_create_maps.htm</a>
    <li><a href="../../public/htm/cm_datamapper_htm.html">cm_datamapper.htm</a>
    <li><a href="../../public/htm/cm_display_set_of_data_htm.html">cm_display_set_of_data.htm</a>
    <li><a href="../../public/htm/cm_feature_htm.html">cm_feature.htm</a>
    <li><a href="../../public/htm/cm_html_snip_htm.html">cm_html_snip.htm</a>
    <li><a href="../../public/htm/cm_install_htm.html">cm_install.htm</a>
    <li><a href="../../public/htm/cm_intro_htm.html">cm_intro.htm</a>
    <li><a href="../../public/htm/cm_md_snip_htm.html">cm_md_snip.htm</a>
    <li><a href="../../public/htm/cm_required_software_htm.html">cm_required_software.htm</a>
    <li><a href="../../public/htm/cm_ruby_htm.html">cm_ruby.htm</a>
    <li><a href="../../public/htm/cm_run_dita_3_0_htm.html">cm_run_dita_3_0.htm</a>
    <li><a href="../../public/htm/cm_run_swcms_htm.html">cm_run_swcms.htm</a>
    <li><a href="../../public/htm/cm_set_variables_htm.html">cm_set_variables.htm</a>
    <li><a href="../../public/htm/cm_setting_menus_htm.html">cm_setting_menus.htm</a>
    <li><a href="../../public/htm/cm_setup_htm.html">cm_setup.htm</a>
    <li><a href="../../public/htm/cm_sinatra_htm.html">cm_sinatra.htm</a>
    <li><a href="../../public/htm/images_htm.html">images.htm</a>
    <li><a href="../../public/htm/images_Daffodil001_htm.html">images_Daffodil001.htm</a>
    <li><a href="../../public/htm/images_chase_htm.html">images_chase.htm</a>
    <li><a href="../../public/htm/images_cindy_htm.html">images_cindy.htm</a>
    <li><a href="../../public/htm/images_home_htm.html">images_home.htm</a>
    <li><a href="../../public/htm/images_jimmy_rollins_htm.html">images_jimmy_rollins.htm</a>
    <li><a href="../../public/htm/images_step_bros_htm.html">images_step_bros.htm</a>
    <li><a href="../../public/htm/images_test123_htm.html">images_test123.htm</a>
    <li><a href="../../public/htm/misc_htm.html">misc.htm</a>
    <li><a href="../../public/htm/misc_dita_app_htm.html">misc_dita_app.htm</a>
    <li><a href="../../public/htm/misc_event_htm.html">misc_event.htm</a>
    <li><a href="../../public/htm/misc_forward_htm.html">misc_forward.htm</a>
    <li><a href="../../public/htm/misc_h2d_htm.html">misc_h2d.htm</a>
    <li><a href="../../public/htm/misc_random_th_08_01_14_htm.html">misc_random_th_08_01_14.htm</a>
    <li><a href="../../public/htm/misc_run_ant_htm.html">misc_run_ant.htm</a>
    <li><a href="../../public/htm/movies_htm.html">movies.htm</a>
    <li><a href="../../public/htm/movies_old_school_htm.html">movies_old_school.htm</a>
    <li><a href="../../public/htm/recent_movies_htm.html">recent_movies.htm</a>
    <li><a href="../../public/htm/recent_movies__htm.html">recent_movies_.htm</a>
    <li><a href="../../public/htm/recent_movies_her_htm.html">recent_movies_her.htm</a>
    <li><a href="../../public/htm/recent_movies_mudd_htm.html">recent_movies_mudd.htm</a>
    <li><a href="../../public/htm/recent_movies_paranoia_htm.html">recent_movies_paranoia.htm</a>
    <li><a href="../../public/htm/sports_events_htm.html">sports_events.htm</a>
    <li><a href="../../public/htm/sports_events__htm.html">sports_events_.htm</a>
    <li><a href="../../public/htm/sports_events_2001_htm.html">sports_events_2001.htm</a>
    <li><a href="../../public/htm/sports_events_2007_ditamap.html">sports_events_2007.ditamap</a>
    <li><a href="../../public/htm/sports_events_2007_htm.html">sports_events_2007.htm</a>
    <li><a href="../../public/htm/sports_events_2009_htm.html">sports_events_2009.htm</a>
    <li><a href="../../public/htm/sports_events_2010_htm.html">sports_events_2010.htm</a>
    <li><a href="../../public/htm/sports_events_2011_htm.html">sports_events_2011.htm</a>
    <li><a href="../../public/htm/sports_events_2013_htm.html">sports_events_2013.htm</a>
    <li><a href="../../public/htm/sports_events_2014_htm.html">sports_events_2014.htm</a>
    <li><a href="../../public/htm/sports_events_2018_htm.html">sports_events_2018.htm</a>
    <li><a href="../../public/htm/table_test_htm.html">table_test.htm</a>
    <li><a href="../../public/htm/test_htm.html">test.htm</a>
    <li><a href="../../public/htm/topic_map_ditamap.html">topic_map.ditamap</a>
    <li><a href="../../public/htm/topic_map_htm.html">topic_map.htm</a>
    <li><a href="../../public/htm/topic_map_athletes_ditamap.html">topic_map_athletes.ditamap</a>
    <li><a href="../../public/htm/topic_map_cms_htm.html">topic_map_cms.htm</a>
    <li><a href="../../public/htm/topic_map_test_htm.html">topic_map_test.htm</a>
    <li><a href="../../public/htm/topic_map_test_1_ditamap.html">topic_map_test_1.ditamap</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/demo/demo_css.html">demo.css</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/demo/demo_html.html">demo.html</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/jquery-te-1_4_0_css.html">jquery-te-1.4.0.css</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/jquery-te-1_4_0_min_js.html">jquery-te-1.4.0.min.js</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/license/AUTHOR_txt.html">AUTHOR</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/license/MIT-LICENSE_txt.html">MIT-LICENSE</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/uncompressed/jquery-te-1_4_0_js.html">jquery-te-1.4.0.js</a>
    <li><a href="../../public/jss/JSS-masterindex_js.html">JSS-masterindex.js</a>
    <li><a href="../../public/jss/jss-front_html.html">jss-front.html</a>
    <li><a href="../../public/jss/jss-hittemplate_js.html">jss-hittemplate.js</a>
    <li><a href="../../public/jss/jss-index_html.html">jss-index.html</a>
    <li><a href="../../public/jss/jss-info_html.html">jss-info.html</a>
    <li><a href="../../public/jss/jss-search_html.html">jss-search.html</a>
    <li><a href="../../public/tocjs/commonltr_css.html">commonltr.css</a>
    <li><a href="../../public/tocjs/commonrtl_css.html">commonrtl.css</a>
    <li><a href="../../public/tocjs/css/check/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/code_css.html">code.css</a>
    <li><a href="../../public/tocjs/css/default/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/folders/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/local/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/menu/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/screen_css.html">screen.css</a>
    <li><a href="../../public/tocjs/event_js.html">event.js</a>
    <li><a href="../../public/tocjs/tocnav_html.html">tocnav.html</a>
    <li><a href="../../public/tocjs/toctree_js.html">toctree.js</a>
    <li><a href="../../public/tocjs/topic_map_cms_html.html">topic_map_cms.html</a>
    <li><a href="../../public/tocjs/topics/cm_create_entries_html.html">cm_create_entries.html</a>
    <li><a href="../../public/tocjs/topics/cm_create_form_html.html">cm_create_form.html</a>
    <li><a href="../../public/tocjs/topics/cm_display_set_of_data_html.html">cm_display_set_of_data.html</a>
    <li><a href="../../public/tocjs/topics/cm_run_dita_3_0_html.html">cm_run_dita_3_0.html</a>
    <li><a href="../../public/tocjs/topics/cm_run_swcms_html.html">cm_run_swcms.html</a>
    <li><a href="../../public/tocjs/topics/cm_set_variables_html.html">cm_set_variables.html</a>
    <li><a href="../../public/tocjs/topics/cm_setup_html.html">cm_setup.html</a>
    <li><a href="../../public/tocjs/topics/cm_usage_html.html">cm_usage.html</a>
    <li><a href="../../public/tocjs/treeview_js.html">treeview.js</a>
    <li><a href="../../public/tocjs/yahoo_js.html">yahoo.js</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page public/tocjs/treeview.js">

<p>/* </p>

<p>This file is part of the DITA Open Toolkit project.</p>

<p>See the accompanying LICENSE file for applicable license.</p>

<p>Copyright © 2006, Yahoo! Inc. All rights reserved.                                                                                                 </p>

<p>Code licensed under the BSD License:                                                                                                                 </p>

<p><a href="http://developer.yahoo.net/yui/license.txt">developer.yahoo.net/yui/license.txt</a>                                                                                                           </p>

<p>version: 0.10.0                                                                                                                                      </p>

<p>*/ </p>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* Contains the tree view state data and the root node.  This is an
* ordered tree; child nodes will be displayed in the order created, and
* there currently is no way to change this.
*
* @constructor
* @todo graft (appendBefore, appendAfter)
* @param {string} id The id of the element that the tree will be inserted
* into.
*/</pre>

<p>YAHOO.widget.TreeView = function(id) {</p>

<pre>if (id) { this.init(id); }</pre>

<p>};</p>

<p>/**</p>

<pre>* Count of all nodes in all trees
* @type int
*/</pre>

<p>YAHOO.widget.TreeView.nodeCount = 0;</p>

<p>YAHOO.widget.TreeView.prototype = {</p>

<pre>/**
 * The id of tree container element
 *
 * @type String
 */
id: null,

 /**
 * Flat collection of all nodes in this tree
 *
 * @type Node[]
 * @private
 */
_nodes: null,

/**
 * We lock the tree control while waiting for the dynamic loader to return
 *
 * @type boolean
 */
locked: false,

/**
 * The animation to use for expanding children, if any
 *
 * @type string
 * @private
 */
_expandAnim: null,

/**
 * The animation to use for collapsing children, if any
 *
 * @type string
 * @private
 */
_collapseAnim: null,

/**
 * The current number of animations that are executing
 *
 * @type int
 * @private
 */
_animCount: 0,

/**
 * The maximum number of animations to run at one time.
 *
 * @type int
 */
maxAnim: 2,

/**
 * Sets up the animation for expanding children
 *
 * @param {string} the type of animation (acceptable constants in YAHOO.widget.TVAnim)
 */
setExpandAnim: function(type) {
    if (YAHOO.widget.TVAnim.isValid(type)) {
        this._expandAnim = type;
    }
},

/**
 * Sets up the animation for collapsing children
 *
 * @param {string} the type of animation (acceptable constants in YAHOO.widget.TVAnim)
 */
setCollapseAnim: function(type) {
    if (YAHOO.widget.TVAnim.isValid(type)) {
        this._collapseAnim = type;
    }
},

/**
 * Perform the expand animation if configured, or just show the
 * element if not configured or too many animations are in progress
 *
 * @param el {HTMLElement} the element to animate
 * @return {boolean} true if animation could be invoked, false otherwise
 */
animateExpand: function(el) {

    if (this._expandAnim &amp;&amp; this._animCount &lt; this.maxAnim) {
        // this.locked = true;
        var tree = this;
        var a = YAHOO.widget.TVAnim.getAnim(this._expandAnim, el, 
                        function() { tree.expandComplete(); });
        if (a) { 
            ++this._animCount;
            a.animate();
        }

        return true;
    }

    return false;
},

/**
 * Perform the collapse animation if configured, or just show the
 * element if not configured or too many animations are in progress
 *
 * @param el {HTMLElement} the element to animate
 * @return {boolean} true if animation could be invoked, false otherwise
 */
animateCollapse: function(el) {

    if (this._collapseAnim &amp;&amp; this._animCount &lt; this.maxAnim) {
        // this.locked = true;
        var tree = this;
        var a = YAHOO.widget.TVAnim.getAnim(this._collapseAnim, el, 
                        function() { tree.collapseComplete(); });
        if (a) { 
            ++this._animCount;
            a.animate();
        }

        return true;
    }

    return false;
},

/**
 * Function executed when the expand animation completes
 */
expandComplete: function() {
    --this._animCount;
    // this.locked = false;
},

/**
 * Function executed when the collapse animation completes
 */
collapseComplete: function() {
    --this._animCount;
    // this.locked = false;
},

/**
 * Initializes the tree
 *
 * @parm {string} id the id of the element that will hold the tree
 * @private
 */
init: function(id) {

    this.id = id;
    this._nodes = [];

    // store a global reference
    YAHOO.widget.TreeView.trees[id] = this;

    // Set up the root node
    this.root = new YAHOO.widget.RootNode(this);

},

/**
 * Renders the tree boilerplate and visible nodes
 */
draw: function() {
    var html = this.root.getHtml();
    if(document.getElementById(this.id))
         document.getElementById(this.id).innerHTML = html;
    /*document.getElementById(this.id).innerHTML = html;*/
    this.firstDraw = false;
},

/**
 * Nodes register themselves with the tree instance when they are created.
 *
 * @param node {Node} the node to register
 * @private
 */
regNode: function(node) {
    this._nodes[node.index] = node;
},

/**
 * Returns the root node of this tree
 *
 * @return {Node} the root node
 */
getRoot: function() {
    return this.root;
},

/**
 * Configures this tree to dynamically load all child data
 *
 * @param {function} fnDataLoader the function that will be called to get the data
 * @param iconMode {int} configures the icon that is displayed when a dynamic
 * load node is expanded the first time without children.  By default, the 
 * &quot;collapse&quot; icon will be used.  If set to 1, the leaf node icon will be
 * displayed.
 */
setDynamicLoad: function(fnDataLoader, iconMode) { 
    this.root.setDynamicLoad(fnDataLoader, iconMode);
},

/**
 * Expands all child nodes.  Note: this conflicts with the &quot;multiExpand&quot;
 * node property.  If expand all is called in a tree with nodes that
 * do not allow multiple siblings to be displayed, only the last sibling
 * will be expanded.
 */
expandAll: function() { 
    if (!this.locked) {
        this.root.expandAll(); 
    }
},

/**
 * Collapses all expanded child nodes in the entire tree.
 */
collapseAll: function() { 
    if (!this.locked) {
        this.root.collapseAll(); 
    }
},

/**
 * Returns a node in the tree that has the specified index (this index
 * is created internally, so this function probably will only be used
 * in html generated for a given node.)
 *
 * @param {int} nodeIndex the index of the node wanted
 * @return {Node} the node with index=nodeIndex, null if no match
 */
getNodeByIndex: function(nodeIndex) {
    var n = this._nodes[nodeIndex];
    return (n) ? n : null;
},

/**
 * Returns a node that has a matching property and value in the data
 * object that was passed into its constructor.  Provides a flexible
 * way for the implementer to get a particular node.
 *
 * @param {object} property the property to search (usually a string)
 * @param {object} value the value we want to find (usuall an int or string)
 * @return {Node} the matching node, null if no match
 */
getNodeByProperty: function(property, value) {
    for (var i in this._nodes) {
        var n = this._nodes[i];
        if (n.data &amp;&amp; value == n.data[property]) {
            return n;
        }
    }

    return null;
},

/**
 * Removes the node and its children, and optionally refreshes the branch 
 * of the tree that was affected.
 * @param {Node} The node to remove
 * @param {boolean} autoRefresh automatically refreshes branch if true
 * @return {boolean} False is there was a problem, true otherwise.
 */
removeNode: function(node, autoRefresh) { 

    // Don&#39;t delete the root node
    if (node.isRoot()) {
        return false;
    }

    // Get the branch that we may need to refresh
    var p = node.parent;
    if (p.parent) {
        p = p.parent;
    }

    // Delete the node and its children
    this._deleteNode(node);

    // Refresh the parent of the parent
    if (autoRefresh &amp;&amp; p &amp;&amp; p.childrenRendered) {
        p.refresh();
    }

    return true;
},

/**
 * Deletes this nodes child collection, recursively.  Also collapses
 * the node, and resets the dynamic load flag.  The primary use for
 * this method is to purge a node and allow it to fetch its data
 * dynamically again.
 * @param {Node} node the node to purge
 */
removeChildren: function(node) { 
    for (var i=0, len=node.children.length;i&lt;len;++i) {
        this._deleteNode(node.children[i]);
    }

    node.childrenRendered = false;
    node.dynamicLoadComplete = false;
    node.collapse();
},

/**
 * Deletes the node and recurses children
 * @private
 */
_deleteNode: function(node) { 
    var p = node.parent;

    // Remove all the child nodes first
    this.removeChildren(node);

    // Update the parent&#39;s collection of children
    var a = [];

    for (i=0, len=p.children.length;i&lt;len;++i) {
        if (p.children[i] != node) {
            a[a.length] = p.children[i];
        }
    }

    p.children = a;

    // reset the childrenRendered flag for the parent
    p.childrenRendered = false;

     // Update the sibling relationship                                                                                                                       
    if (node.previousSibling) {                                                                                                                              
        node.previousSibling.nextSibling = node.nextSibling;                                                                                                   
    }                                                                                                                                                        

    if (node.nextSibling) {                                                                                                                                  
        node.nextSibling.previousSibling = node.previousSibling;                                                                                               
    }

    // Update the tree&#39;s node collection 
    delete this._nodes[node.index];
},

/**
 * Abstract method that is executed when a node is expanded
 *
 * @param node {Node} the node that was expanded
 */
onExpand: function(node) { },

/**
 * Abstract method that is executed when a node is collapsed
 *
 * @param node {Node} the node that was collapsed.
 */
onCollapse: function(node) { }</pre>

<p>};</p>

<p>/**</p>

<pre>* Global cache of tree instances
*
* @type Array
* @private
*/</pre>

<p>YAHOO.widget.TreeView.trees = [];</p>

<p>/**</p>

<pre>* Global method for getting a tree by its id.  Used in the generated
* tree html.
*
* @param treeId {String} the id of the tree instance
* @return {TreeView} the tree instance requested, null if not found.
*/</pre>

<p>YAHOO.widget.TreeView.getTree = function(treeId) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">t</span> = <span class="ruby-constant">YAHOO</span>.<span class="ruby-identifier">widget</span>.<span class="ruby-constant">TreeView</span>.<span class="ruby-identifier">trees</span>[<span class="ruby-identifier">treeId</span>];
<span class="ruby-keyword">return</span> (<span class="ruby-identifier">t</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">t</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">null</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre>* Global method for getting a node by its id.  Used in the generated
* tree html.
*
* @param treeId {String} the id of the tree instance
* @param nodeIndex {String} the index of the node to return
* @return {Node} the node instance requested, null if not found
*/</pre>

<p>YAHOO.widget.TreeView.getNode = function(treeId, nodeIndex) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">t</span> = <span class="ruby-constant">YAHOO</span>.<span class="ruby-identifier">widget</span>.<span class="ruby-constant">TreeView</span>.<span class="ruby-identifier">getTree</span>(<span class="ruby-identifier">treeId</span>);
<span class="ruby-keyword">return</span> (<span class="ruby-identifier">t</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">t</span>.<span class="ruby-identifier">getNodeByIndex</span>(<span class="ruby-identifier">nodeIndex</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">null</span>;
</pre>

<p>};</p>

<p>/**</p>

<pre>* Adds an event.  Replace with event manager when available
*
* @param el the elment to bind the handler to
* @param {string} sType the type of event handler
* @param {function} fn the callback to invoke
* @param {boolean} capture if true event is capture phase, bubble otherwise
*/</pre>

<p>YAHOO.widget.TreeView.addHandler = function (el, sType, fn, capture) {</p>

<pre>capture = (capture) ? true : false;
if (el.addEventListener) {
        el.addEventListener(sType, fn, capture);
} else if (el.attachEvent) {
        el.attachEvent(&quot;on&quot; + sType, fn);
} else {
        el[&quot;on&quot; + sType] = fn;
}</pre>

<p>};</p>

<p>/**</p>

<pre>* Attempts to preload the images defined in the styles used to draw the tree by
* rendering off-screen elements that use the styles.
*/</pre>

<p>YAHOO.widget.TreeView.preload = function() {</p>

<pre>var styles = [
        &quot;ygtvtn&quot;,       
        &quot;ygtvtm&quot;,       
        &quot;ygtvtmh&quot;,      
        &quot;ygtvtp&quot;,       
        &quot;ygtvtph&quot;,      
        &quot;ygtvln&quot;,       
        &quot;ygtvlm&quot;,       
        &quot;ygtvlmh&quot;,      
        &quot;ygtvlp&quot;,       
        &quot;ygtvlph&quot;,      
        &quot;ygtvloading&quot;
        ];

var sb = [];

for (var i = 0; i &lt; styles.length; ++i) { 
        sb[sb.length] = &#39;&lt;span class=&quot;&#39; + styles[i] + &#39;&quot;&gt;&amp;nbsp;&lt;/span&gt;&#39;;
}

var f = document.createElement(&quot;div&quot;);
var s = f.style;
s.position = &quot;absolute&quot;;
s.top = &quot;-1000px&quot;;
s.left = &quot;-1000px&quot;;
f.innerHTML = sb.join(&quot;&quot;);

document.body.appendChild(f);</pre>

<p>};</p>

<p>YAHOO.widget.TreeView.addHandler(window, </p>

<pre>&quot;load&quot;, YAHOO.widget.TreeView.preload);</pre>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* The base class for all tree nodes.  The node&#39;s presentation and behavior in
* response to mouse events is handled in Node subclasses.
*
* @param oData {object} a string or object containing the data that will
* be used to render this node
* @param oParent {Node} this node&#39;s parent node
* @param expanded {boolean} the initial expanded/collapsed state
* @constructor
*/</pre>

<p>YAHOO.widget.Node = function(oData, oParent, expanded) {</p>

<pre>if (oParent) { this.init(oData, oParent, expanded); }</pre>

<p>};</p>

<p>YAHOO.widget.Node.prototype = {</p>

<pre>/**
 * The index for this instance obtained from global counter in YAHOO.widget.TreeView.
 *
 * @type int
 */
index: 0,

/**
 * This node&#39;s child node collection.
 *
 * @type Node[] 
 */
children: null,

/**
 * Tree instance this node is part of
 *
 * @type TreeView
 */
tree: null,

/**
 * The data linked to this node.  This can be any object or primitive
 * value, and the data can be used in getNodeHtml().
 *
 * @type object
 */
data: null,

/**
 * Parent node
 *
 * @type Node
 */
parent: null,

/**
 * The depth of this node.  We start at -1 for the root node.
 *
 * @type int
 */
depth: -1,

/**
 * The href for the node&#39;s label.  If one is not specified, the href will
 * be set so that it toggles the node.
 *
 * @type string
 */
href: null,

/**
 * The label href target, defaults to current window
 *
 * @type string
 */
target: &quot;_self&quot;,

/**
 * The node&#39;s expanded/collapsed state
 *
 * @type boolean
 */
expanded: false,

/**
 * Can multiple children be expanded at once?
 *
 * @type boolean
 */
multiExpand: true,

/**
 * Should we render children for a collapsed node?  It is possible that the
 * implementer will want to render the hidden data...  @todo verify that we 
 * need this, and implement it if we do.
 *
 * @type boolean
 */
renderHidden: false,

/**
 * This flag is set to true when the html is generated for this node&#39;s
 * children, and set to false when new children are added.
 * @type boolean
 */
childrenRendered: false,

/**
 * Dynamically loaded nodes only fetch the data the first time they are
 * expanded.  This flag is set to true once the data has been fetched.
 * @type boolean
 */
dynamicLoadComplete: false,

/**
 * This node&#39;s previous sibling
 *
 * @type Node
 */
previousSibling: null,

/**
 * This node&#39;s next sibling
 *
 * @type Node
 */
nextSibling: null,

/**
 * We can set the node up to call an external method to get the child
 * data dynamically.
 *
 * @type boolean
 * @private
 */
_dynLoad: false,

/**
 * Function to execute when we need to get this node&#39;s child data.
 *
 * @type function
 */
dataLoader: null,

/**
 * This is true for dynamically loading nodes while waiting for the
 * callback to return.
 *
 * @type boolean
 */
isLoading: false,

/**
 * The toggle/branch icon will not show if this is set to false.  This
 * could be useful if the implementer wants to have the child contain
 * extra info about the parent, rather than an actual node.
 *
 * @type boolean
 */
hasIcon: true,

/**
 * Used to configure what happens when a dynamic load node is expanded
 * and we discover that it does not have children.  By default, it is
 * treated as if it still could have children (plus/minus icon).  Set
 * iconMode to have it display like a leaf node instead.
 * @type int
 */
iconMode: 0,

/**
 * The node type
 * @private
 */
_type: &quot;Node&quot;,

/*
spacerPath: &quot;http://us.i1.yimg.com/us.yimg.com/i/space.gif&quot;,
expandedText: &quot;Expanded&quot;,
collapsedText: &quot;Collapsed&quot;,
loadingText: &quot;Loading&quot;,
*/

/**
 * Initializes this node, gets some of the properties from the parent
 *
 * @param oData {object} a string or object containing the data that will
 * be used to render this node
 * @param oParent {Node} this node&#39;s parent node
 * @param expanded {boolean} the initial expanded/collapsed state
 */
init: function(oData, oParent, expanded) {
    this.data               = oData;
    this.children   = [];
    this.index              = YAHOO.widget.TreeView.nodeCount;
    ++YAHOO.widget.TreeView.nodeCount;
    this.expanded   = expanded;

    // oParent should never be null except when we create the root node.
    if (oParent) {
        this.tree                   = oParent.tree;
        this.parent                 = oParent;
        this.href                   = &quot;javascript:&quot; + this.getToggleLink();
        this.depth                  = oParent.depth + 1;
        this.multiExpand    = oParent.multiExpand;

        oParent.appendChild(this);
    }
},

/**
 * Appends a node to the child collection.
 *
 * @param node {Node} the new node
 * @return {Node} the child node
 * @private
 * @TODO insertBefore, insertAfter
 */
appendChild: function(node) {
    if (this.hasChildren()) {
        var sib = this.children[this.children.length - 1];
        sib.nextSibling = node;
        node.previousSibling = sib;
    }

    this.tree.regNode(node);
    this.children[this.children.length] = node;
    this.childrenRendered = false;
    return node;

},

/**
 * Returns a node array of this node&#39;s siblings, null if none.
 *
 * @return Node[]
 */
getSiblings: function() {
    return this.parent.children;
},

/**
 * Shows this node&#39;s children
 */
showChildren: function() {
    if (!this.tree.animateExpand(this.getChildrenEl())) {
        if (this.hasChildren()) {
            this.getChildrenEl().style.display = &quot;&quot;;
        }
    }
},

/**
 * Hides this node&#39;s children
 */
hideChildren: function() {

    if (!this.tree.animateCollapse(this.getChildrenEl())) {
        this.getChildrenEl().style.display = &quot;none&quot;;
    }
},

/**
 * Returns the id for this node&#39;s container div
 *
 * @return {string} the element id
 */
getElId: function() {
    return &quot;ygtv&quot; + this.index;
},

/**
 * Returns the id for this node&#39;s children div
 *
 * @return {string} the element id for this node&#39;s children div
 */
getChildrenElId: function() {
    return &quot;ygtvc&quot; + this.index;
},

/**
 * Returns the id for this node&#39;s toggle element
 *
 * @return {string} the toggel element id
 */
getToggleElId: function() {
    return &quot;ygtvt&quot; + this.index;
},

/**
 * Returns the id for this node&#39;s spacer image.  The spacer is positioned
 * over the toggle and provides feedback for screen readers.
 * @return {string} the id for the spacer image
 */
/*
getSpacerId: function() {
    return &quot;ygtvspacer&quot; + this.index;
}, 
*/

/**
 * Returns this node&#39;s container html element
 * @return {HTMLElement} the container html element
 */
getEl: function() {
    return document.getElementById(this.getElId());
},

/**
 * Returns the div that was generated for this node&#39;s children
 * @return {HTMLElement} this node&#39;s children div
 */
getChildrenEl: function() {
    return document.getElementById(this.getChildrenElId());
},

/**
 * Returns the element that is being used for this node&#39;s toggle.
 * @return {HTMLElement} this node&#39;s toggle html element
 */
getToggleEl: function() {
    return document.getElementById(this.getToggleElId());
},

/**
 * Returns the element that is being used for this node&#39;s spacer.
 * @return {HTMLElement} this node&#39;s spacer html element
 */
/*
getSpacer: function() {
    return document.getElementById( this.getSpacerId() ) || {};
},
*/

/*
getStateText: function() {
    if (this.isLoading) {
        return this.loadingText;
    } else if (this.hasChildren(true)) {
        if (this.expanded) {
            return this.expandedText;
        } else {
            return this.collapsedText;
        }
    } else {
        return &quot;&quot;;
    }
},
*/

/**
 * Generates the link that will invoke this node&#39;s toggle method
 * @return {string} the javascript url for toggling this node
 */
getToggleLink: function() {
    return &quot;YAHOO.widget.TreeView.getNode(\&#39;&quot; + this.tree.id + &quot;\&#39;,&quot; + 
        this.index + &quot;).toggle()&quot;;
},

/**
 * Hides this nodes children (creating them if necessary), changes the
 * toggle style.
 */
collapse: function() {
    // Only collapse if currently expanded
    if (!this.expanded) { return; }

    // fire the collapse event handler
    var ret = this.tree.onCollapse(this);

    if (&quot;undefined&quot; != typeof ret &amp;&amp; !ret) {
        return;
    }

    if (!this.getEl()) {
        this.expanded = false;
        return;
    }

    // hide the child div
    this.hideChildren();
    this.expanded = false;

    if (this.hasIcon) {
        this.getToggleEl().className = this.getStyle();
    }

    // this.getSpacer().title = this.getStateText();

},

/**
 * Shows this nodes children (creating them if necessary), changes the
 * toggle style, and collapses its siblings if multiExpand is not set.
 */
expand: function() {
    // Only expand if currently collapsed.
    if (this.expanded) { return; }

    // fire the expand event handler
    var ret = this.tree.onExpand(this);

    if (&quot;undefined&quot; != typeof ret &amp;&amp; !ret) {
        return;
    }

    if (!this.getEl()) {
        this.expanded = true;
        return;
    }

    if (! this.childrenRendered) {
        this.getChildrenEl().innerHTML = this.renderChildren();
    } else {
    }

    this.expanded = true;
    if (this.hasIcon) {
        this.getToggleEl().className = this.getStyle();
    }

    // this.getSpacer().title = this.getStateText();

    // We do an extra check for children here because the lazy
    // load feature can expose nodes that have no children.

    // if (!this.hasChildren()) {
    if (this.isLoading) {
        this.expanded = false;
        return;
    }

    if (! this.multiExpand) {
        var sibs = this.getSiblings();
        for (var i=0; i&lt;sibs.length; ++i) {
            if (sibs[i] != this &amp;&amp; sibs[i].expanded) { 
                sibs[i].collapse(); 
            }
        }
    }

    this.showChildren();
},

/**
 * Returns the css style name for the toggle
 *
 * @return {string} the css class for this node&#39;s toggle
 */
getStyle: function() {
    if (this.isLoading) {
        return &quot;ygtvloading&quot;;
    } else {
        // location top or bottom, middle nodes also get the top style
        var loc = (this.nextSibling) ? &quot;t&quot; : &quot;l&quot;;

        // type p=plus(expand), m=minus(collapase), n=none(no children)
        var type = &quot;n&quot;;
        if (this.hasChildren(true) || (this.isDynamic() &amp;&amp; !this.getIconMode())) {
        // if (this.hasChildren(true)) {
            type = (this.expanded) ? &quot;m&quot; : &quot;p&quot;;
        }

        return &quot;ygtv&quot; + loc + type;
    }
},

/**
 * Returns the hover style for the icon
 * @return {string} the css class hover state
 */
getHoverStyle: function() { 
    var s = this.getStyle();
    if (this.hasChildren(true) &amp;&amp; !this.isLoading) { 
        s += &quot;h&quot;; 
    }
    return s;
},

/**
 * Recursively expands all of this node&#39;s children.
 */
expandAll: function() { 
    for (var i=0;i&lt;this.children.length;++i) {
        var c = this.children[i];
        if (c.isDynamic()) {
            alert(&quot;Not supported (lazy load + expand all)&quot;);
            break;
        } else if (! c.multiExpand) {
            alert(&quot;Not supported (no multi-expand + expand all)&quot;);
            break;
        } else {
            c.expand();
            c.expandAll();
        }
    }
},

/**
 * Recursively collapses all of this node&#39;s children.
 */
collapseAll: function() { 
    for (var i=0;i&lt;this.children.length;++i) {
        this.children[i].collapse();
        this.children[i].collapseAll();
    }
},

/**
 * Configures this node for dynamically obtaining the child data
 * when the node is first expanded.  Calling it without the callback
 * will turn off dynamic load for the node.
 *
 * @param fmDataLoader {function} the function that will be used to get the data.
 * @param iconMode {int} configures the icon that is displayed when a dynamic
 * load node is expanded the first time without children.  By default, the 
 * &quot;collapse&quot; icon will be used.  If set to 1, the leaf node icon will be
 * displayed.
 */
setDynamicLoad: function(fnDataLoader, iconMode) { 
    if (fnDataLoader) {
        this.dataLoader = fnDataLoader;
        this._dynLoad = true;
    } else {
        this.dataLoader = null;
        this._dynLoad = false;
    }

    if (iconMode) {
        this.iconMode = iconMode;
    }
},

/**
 * Evaluates if this node is the root node of the tree
 *
 * @return {boolean} true if this is the root node
 */
isRoot: function() { 
    return (this == this.tree.root);
},

/**
 * Evaluates if this node&#39;s children should be loaded dynamically.  Looks for
 * the property both in this instance and the root node.  If the tree is
 * defined to load all children dynamically, the data callback function is
 * defined in the root node
 *
 * @return {boolean} true if this node&#39;s children are to be loaded dynamically
 */
isDynamic: function() { 
    var lazy = (!this.isRoot() &amp;&amp; (this._dynLoad || this.tree.root._dynLoad));
    return lazy;
},

getIconMode: function() {
    return (this.iconMode || this.tree.root.iconMode);
},

/**
 * Checks if this node has children.  If this node is lazy-loading and the
 * children have not been rendered, we do not know whether or not there
 * are actual children.  In most cases, we need to assume that there are
 * children (for instance, the toggle needs to show the expandable 
 * presentation state).  In other times we want to know if there are rendered
 * children.  For the latter, &quot;checkForLazyLoad&quot; should be false.
 *
 * @param checkForLazyLoad {boolean} should we check for unloaded children?
 * @return {boolean} true if this has children or if it might and we are
 * checking for this condition.
 */
hasChildren: function(checkForLazyLoad) { 
    return ( this.children.length &gt; 0 || 
            (checkForLazyLoad &amp;&amp; this.isDynamic() &amp;&amp; !this.dynamicLoadComplete) );
},

/**
 * Expands if node is collapsed, collapses otherwise.
 */
toggle: function() {
    if (!this.tree.locked &amp;&amp; ( this.hasChildren(true) || this.isDynamic()) ) {
        if (this.expanded) { this.collapse(); } else { this.expand(); }
    }
},

/**
 * Returns the markup for this node and its children.
 *
 * @return {string} the markup for this node and its expanded children.
 */
getHtml: function() {
    var sb = [];
    sb[sb.length] = &#39;&lt;div class=&quot;ygtvitem&quot; id=&quot;&#39; + this.getElId() + &#39;&quot;&gt;&#39;;
    sb[sb.length] = this.getNodeHtml();
    sb[sb.length] = this.getChildrenHtml();
    sb[sb.length] = &#39;&lt;/div&gt;&#39;;
    return sb.join(&quot;&quot;);
},

/**
 * Called when first rendering the tree.  We always build the div that will
 * contain this nodes children, but we don&#39;t render the children themselves
 * unless this node is expanded.
 *
 * @return {string} the children container div html and any expanded children
 * @private
 */
getChildrenHtml: function() {

    var sb = [];
    sb[sb.length] = &#39;&lt;div class=&quot;ygtvchildren&quot;&#39;;
    sb[sb.length] = &#39; id=&quot;&#39; + this.getChildrenElId() + &#39;&quot;&#39;;
    if (!this.expanded) {
        sb[sb.length] = &#39; style=&quot;display:none;&quot;&#39;;
    }
    sb[sb.length] = &#39;&gt;&#39;;

    // Don&#39;t render the actual child node HTML unless this node is expanded.
    if ( (this.hasChildren(true) &amp;&amp; this.expanded) ||
            (this.renderHidden &amp;&amp; !this.isDynamic()) ) {
        sb[sb.length] = this.renderChildren();
    }

    sb[sb.length] = &#39;&lt;/div&gt;&#39;;

    return sb.join(&quot;&quot;);
},

/**
 * Generates the markup for the child nodes.  This is not done until the node
 * is expanded.
 *
 * @return {string} the html for this node&#39;s children
 * @private
 */
renderChildren: function() {

    var node = this;

    if (this.isDynamic() &amp;&amp; !this.dynamicLoadComplete) {
        this.isLoading = true;
        this.tree.locked = true;

        if (this.dataLoader) {

            setTimeout( 
                function() {
                    node.dataLoader(node, 
                        function() { 
                            node.loadComplete(); 
                        });
                }, 10);

        } else if (this.tree.root.dataLoader) {

            setTimeout( 
                function() {
                    node.tree.root.dataLoader(node, 
                        function() { 
                            node.loadComplete(); 
                        });
                }, 10);

        } else {
            return &quot;Error: data loader not found or not specified.&quot;;
        }

        return &quot;&quot;;

    } else {
        return this.completeRender();
    }
},

/**
 * Called when we know we have all the child data.
 * @return {string} children html
 */
completeRender: function() {
    var sb = [];

    for (var i=0; i &lt; this.children.length; ++i) {
        this.children[i].childrenRendered = false;
        sb[sb.length] = this.children[i].getHtml();
    }

    this.childrenRendered = true;

    return sb.join(&quot;&quot;);
},

/**
 * Load complete is the callback function we pass to the data provider
 * in dynamic load situations.
 */
loadComplete: function() {
    this.getChildrenEl().innerHTML = this.completeRender();
    this.dynamicLoadComplete = true;
    this.isLoading = false;
    this.expand();
    this.tree.locked = false;
},

/**
 * Returns this node&#39;s ancestor at the specified depth.
 *
 * @param {int} depth the depth of the ancestor.
 * @return {Node} the ancestor
 */
getAncestor: function(depth) {
    if (depth &gt;= this.depth || depth &lt; 0)  {
        return null;
    }

    var p = this.parent;

    while (p.depth &gt; depth) {
        p = p.parent;
    }

    return p;
},

/**
 * Returns the css class for the spacer at the specified depth for
 * this node.  If this node&#39;s ancestor at the specified depth
 * has a next sibling the presentation is different than if it
 * does not have a next sibling
 *
 * @param {int} depth the depth of the ancestor.
 * @return {string} the css class for the spacer
 */
getDepthStyle: function(depth) {
    return (this.getAncestor(depth).nextSibling) ? 
        &quot;ygtvdepthcell&quot; : &quot;ygtvblankdepthcell&quot;;
},

/**
 * Get the markup for the node.  This is designed to be overrided so that we can
 * support different types of nodes.
 *
 * @return {string} The HTML that will render this node.
 */
getNodeHtml: function() { 
    return &quot;&quot;; 
},

/**
 * Regenerates the html for this node and its children.  To be used when the
 * node is expanded and new children have been added.
 */
refresh: function() {
    // this.loadComplete();
    this.getChildrenEl().innerHTML = this.completeRender();

    if (this.hasIcon) {
        var el = this.getToggleEl();
        if (el) {
            el.className = this.getStyle();
        }
    }
}</pre>

<p>};</p>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* A custom YAHOO.widget.Node that handles the unique nature of 
* the virtual, presentationless root node.
*
* @extends YAHOO.widget.Node
* @constructor
*/</pre>

<p>YAHOO.widget.RootNode = function(oTree) {</p>

<pre>// Initialize the node with null params.  The root node is a
// special case where the node has no presentation.  So we have
// to alter the standard properties a bit.
this.init(null, null, true);

/**
 * For the root node, we get the tree reference from as a param
 * to the constructor instead of from the parent element.
 *
 * @type TreeView
 */
this.tree = oTree;</pre>

<p>}; YAHOO.widget.RootNode.prototype = new YAHOO.widget.Node();</p>

<p>// overrides YAHOO.widget.Node YAHOO.widget.RootNode.prototype.getNodeHtml = function() { </p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-string">&quot;&quot;</span>;
</pre>

<p>};</p>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* The default node presentation.  The first parameter should be
* either a string that will be used as the node&#39;s label, or an object
* that has a string propery called label.  By default, the clicking the
* label will toggle the expanded/collapsed state of the node.  By
* changing the href property of the instance, this behavior can be
* changed so that the label will go to the specified href.
*
* @extends YAHOO.widget.Node
* @constructor
* @param oData {object} a string or object containing the data that will
* be used to render this node
* @param oParent {YAHOO.widget.Node} this node&#39;s parent node
* @param expanded {boolean} the initial expanded/collapsed state
*/</pre>

<p>YAHOO.widget.TextNode = function(oData, oParent, expanded) {</p>

<pre>this.type = &quot;TextNode&quot;;

    if (oParent) { 
            this.init(oData, oParent, expanded);
            this.setUpLabel(oData);
    }</pre>

<p>};</p>

<p>YAHOO.widget.TextNode.prototype = new YAHOO.widget.Node();</p>

<p>/**</p>

<pre>* The CSS class for the label href.  Defaults to ygtvlabel, but can be
* overridden to provide a custom presentation for a specific node.
*
* @type string
*/</pre>

<p>YAHOO.widget.TextNode.prototype.labelStyle = “ygtvlabel”;</p>

<p>/**</p>

<pre>* The derived element id of the label for this node
*
* @type string
*/</pre>

<p>YAHOO.widget.TextNode.prototype.labelElId = null;</p>

<p>/**</p>

<pre>* The text for the label.  It is assumed that the oData parameter will
* either be a string that will be used as the label, or an object that
* has a property called &quot;label&quot; that we will use.
*
* @type string
*/</pre>

<p>YAHOO.widget.TextNode.prototype.label = null;</p>

<p>/**</p>

<pre>* Sets up the node label
* 
* @param oData string containing the label, or an object with a label property
*/</pre>

<p>YAHOO.widget.TextNode.prototype.setUpLabel = function(oData) { </p>

<pre>    if (typeof oData == &quot;string&quot;) {
            oData = { label: oData };
    }
    this.label = oData.label;

    // update the link
    if (oData.href) {
            this.href = oData.href;
    }

    // set the target
    if (oData.target) {
            this.target = oData.target;
    }

if (oData.style) {
    this.labelStyle = oData.style;
}

    this.labelElId = &quot;ygtvlabelel&quot; + this.index;</pre>

<p>};</p>

<p>/**</p>

<pre>* Returns the label element
*
* @return {object} the element
*/</pre>

<p>YAHOO.widget.TextNode.prototype.getLabelEl = function() { </p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">getElementById</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">labelElId</span>);
</pre>

<p>};</p>

<p>// overrides YAHOO.widget.Node YAHOO.widget.TextNode.prototype.getNodeHtml = function() { </p>

<pre>    var sb = [];

    sb[sb.length] = &#39;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&#39;;
    sb[sb.length] = &#39;&lt;tr&gt;&#39;;

    for (i=0;i&lt;this.depth;++i) {
            // sb[sb.length] = &#39;&lt;td class=&quot;ygtvdepthcell&quot;&gt;&amp;nbsp;&lt;/td&gt;&#39;;
            sb[sb.length] = &#39;&lt;td class=&quot;&#39; + this.getDepthStyle(i) + &#39;&quot;&gt;&amp;nbsp;&lt;/td&gt;&#39;;
    }

    var getNode = &#39;YAHOO.widget.TreeView.getNode(\&#39;&#39; +
                                    this.tree.id + &#39;\&#39;,&#39; + this.index + &#39;)&#39;;

    sb[sb.length] = &#39;&lt;td&#39;;
    // sb[sb.length] = &#39; onselectstart=&quot;return false&quot;&#39;;
    sb[sb.length] = &#39; id=&quot;&#39; + this.getToggleElId() + &#39;&quot;&#39;;
    sb[sb.length] = &#39; class=&quot;&#39; + this.getStyle() + &#39;&quot;&#39;;
    if (this.hasChildren(true)) {
            sb[sb.length] = &#39; onmouseover=&quot;this.className=&#39;;
            sb[sb.length] = getNode + &#39;.getHoverStyle()&quot;&#39;;
            sb[sb.length] = &#39; onmouseout=&quot;this.className=&#39;;
            sb[sb.length] = getNode + &#39;.getStyle()&quot;&#39;;
    }

    sb[sb.length] = &#39; onclick=&quot;javascript:&#39; + this.getToggleLink() + &#39;&quot;&gt;&#39;;

/*
    sb[sb.length] = &#39;&lt;img id=&quot;&#39; + this.getSpacerId() + &#39;&quot;&#39;;
sb[sb.length] = &#39; alt=&quot;&quot;&#39;;
sb[sb.length] = &#39; tabindex=0&#39;;
sb[sb.length] = &#39; src=&quot;&#39; + this.spacerPath + &#39;&quot;&#39;;
sb[sb.length] = &#39; title=&quot;&#39; + this.getStateText() + &#39;&quot;&#39;;
sb[sb.length] = &#39; class=&quot;ygtvspacer&quot;&#39;;
// sb[sb.length] = &#39; onkeypress=&quot;return &#39; + getNode + &#39;&quot;.onKeyPress()&quot;&#39;;
sb[sb.length] = &#39; /&gt;&#39;;
*/

    sb[sb.length] = &#39;&amp;nbsp;&#39;;

    sb[sb.length] = &#39;&lt;/td&gt;&#39;;
    sb[sb.length] = &#39;&lt;td&gt;&#39;;
    sb[sb.length] = &#39;&lt;a&#39;;
    sb[sb.length] = &#39; id=&quot;&#39; + this.labelElId + &#39;&quot;&#39;;
    sb[sb.length] = &#39; class=&quot;&#39; + this.labelStyle + &#39;&quot;&#39;;
    sb[sb.length] = &#39; href=&quot;&#39; + this.href + &#39;&quot;&#39;;
    sb[sb.length] = &#39; target=&quot;&#39; + this.target + &#39;&quot;&#39;;

    sb[sb.length] = &#39; onclick=&quot;return &#39; + getNode + &#39;.onLabelClick(&#39; + getNode +&#39;)&quot;&#39;;
    /*sb[sb.length] = &#39; onclick=&quot;javascript:&#39; + this.getToggleLink() + &#39;.onLabelClick(&#39; + getNode
    +&#39;)&quot;&#39;;*/

    if (this.hasChildren(true)) {
            sb[sb.length] = &#39; onmouseover=&quot;document.getElementById(\&#39;&#39;;
            sb[sb.length] = this.getToggleElId() + &#39;\&#39;).className=&#39;;
            sb[sb.length] = getNode + &#39;.getHoverStyle()&quot;&#39;;
            sb[sb.length] = &#39; onmouseout=&quot;document.getElementById(\&#39;&#39;;
            sb[sb.length] = this.getToggleElId() + &#39;\&#39;).className=&#39;;
            sb[sb.length] = getNode + &#39;.getStyle()&quot;&#39;;
    }
    sb[sb.length] = &#39; &gt;&#39;;
    sb[sb.length] = this.label;
    sb[sb.length] = &#39;&lt;/a&gt;&#39;;
    sb[sb.length] = &#39;&lt;/td&gt;&#39;;
    sb[sb.length] = &#39;&lt;/tr&gt;&#39;;
    sb[sb.length] = &#39;&lt;/table&gt;&#39;;

    return sb.join(&quot;&quot;);</pre>

<p>};</p>

<p>/**</p>

<pre>* Executed when the label is clicked
* @param me {Node} this node
* @scope the anchor tag clicked
* @return false to cancel the anchor click
*/</pre>

<p>YAHOO.widget.TextNode.prototype.onLabelClick = function(me) { </p>

<pre>//return true;</pre>

<p>}; /* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* A menu-specific implementation that differs from TextNode in that only 
* one sibling can be expanded at a time.
* @extends YAHOO.widget.TextNode
* @constructor
*/</pre>

<p>YAHOO.widget.MenuNode = function(oData, oParent, expanded) {</p>

<pre>    if (oParent) { 
            this.init(oData, oParent, expanded);
            this.setUpLabel(oData);
    }

/**
 * Menus usually allow only one branch to be open at a time.
 * @type boolean
 */
    this.multiExpand = false;</pre>

<p>};</p>

<p>YAHOO.widget.MenuNode.prototype = new YAHOO.widget.TextNode();</p>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* This implementation takes either a string or object for the
* oData argument.  If is it a string, we will use it for the display
* of this node (and it can contain any html code).  If the parameter
* is an object, we look for a parameter called &quot;html&quot; that will be
* used for this node&#39;s display.
*
* @extends YAHOO.widget.Node
* @constructor
* @param oData {object} a string or object containing the data that will
* be used to render this node
* @param oParent {YAHOO.widget.Node} this node&#39;s parent node
* @param expanded {boolean} the initial expanded/collapsed state
* @param hasIcon {boolean} specifies whether or not leaf nodes should
* have an icon
*/</pre>

<p>YAHOO.widget.HTMLNode = function(oData, oParent, expanded, hasIcon) {</p>

<pre>if (oParent) { 
    this.init(oData, oParent, expanded);
    this.initContent(oData, hasIcon);
}</pre>

<p>};</p>

<p>YAHOO.widget.HTMLNode.prototype = new YAHOO.widget.Node();</p>

<p>/**</p>

<pre>* The CSS class for the label href.  Defaults to ygtvlabel, but can be
* overridden to provide a custom presentation for a specific node.
*
* @type string
*/</pre>

<p>YAHOO.widget.HTMLNode.prototype.contentStyle = “ygtvhtml”;</p>

<p>/**</p>

<pre>* The generated id that will contain the data passed in by the implementer.
*
* @type string
*/</pre>

<p>YAHOO.widget.HTMLNode.prototype.contentElId = null;</p>

<p>/**</p>

<pre>* The HTML content to use for this node&#39;s display
*
* @type string
*/</pre>

<p>YAHOO.widget.HTMLNode.prototype.content = null;</p>

<p>/**</p>

<pre>* Sets up the node label
*
* @param {object} An html string or object containing an html property
* @param {boolean} hasIcon determines if the node will be rendered with an
* icon or not
*/</pre>

<p>YAHOO.widget.HTMLNode.prototype.initContent = function(oData, hasIcon) { </p>

<pre>if (typeof oData == &quot;string&quot;) {
    oData = { html: oData };
}

this.html = oData.html;
this.contentElId = &quot;ygtvcontentel&quot; + this.index;
this.hasIcon = hasIcon;</pre>

<p>};</p>

<p>/**</p>

<pre>* Returns the outer html element for this node&#39;s content
*
* @return {HTMLElement} the element
*/</pre>

<p>YAHOO.widget.HTMLNode.prototype.getContentEl = function() { </p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">document</span>.<span class="ruby-identifier">getElementById</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">contentElId</span>);
</pre>

<p>};</p>

<p>// overrides YAHOO.widget.Node YAHOO.widget.HTMLNode.prototype.getNodeHtml = function() { </p>

<pre>var sb = [];

sb[sb.length] = &#39;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&#39;;
sb[sb.length] = &#39;&lt;tr&gt;&#39;;

for (i=0;i&lt;this.depth;++i) {
    sb[sb.length] = &#39;&lt;td class=&quot;&#39; + this.getDepthStyle(i) + &#39;&quot;&gt;&amp;nbsp;&lt;/td&gt;&#39;;
}

if (this.hasIcon) {
    sb[sb.length] = &#39;&lt;td&#39;;
    sb[sb.length] = &#39; id=&quot;&#39; + this.getToggleElId() + &#39;&quot;&#39;;
    sb[sb.length] = &#39; class=&quot;&#39; + this.getStyle() + &#39;&quot;&#39;;
    sb[sb.length] = &#39; onclick=&quot;javascript:&#39; + this.getToggleLink() + &#39;&quot;&#39;;
    if (this.hasChildren(true)) {
        sb[sb.length] = &#39; onmouseover=&quot;this.className=&#39;;
        sb[sb.length] = &#39;YAHOO.widget.TreeView.getNode(\&#39;&#39;;
        sb[sb.length] = this.tree.id + &#39;\&#39;,&#39; + this.index +  &#39;).getHoverStyle()&quot;&#39;;
        sb[sb.length] = &#39; onmouseout=&quot;this.className=&#39;;
        sb[sb.length] = &#39;YAHOO.widget.TreeView.getNode(\&#39;&#39;;
        sb[sb.length] = this.tree.id + &#39;\&#39;,&#39; + this.index +  &#39;).getStyle()&quot;&#39;;
    }
    sb[sb.length] = &#39;&gt;&amp;nbsp;&lt;/td&gt;&#39;;
}

sb[sb.length] = &#39;&lt;td&#39;;
sb[sb.length] = &#39; id=&quot;&#39; + this.contentElId + &#39;&quot;&#39;;
sb[sb.length] = &#39; class=&quot;&#39; + this.contentStyle + &#39;&quot;&#39;;
sb[sb.length] = &#39; &gt;&#39;;
sb[sb.length] = this.html;
sb[sb.length] = &#39;&lt;/td&gt;&#39;;
sb[sb.length] = &#39;&lt;/tr&gt;&#39;;
sb[sb.length] = &#39;&lt;/table&gt;&#39;;

return sb.join(&quot;&quot;);</pre>

<p>};</p>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* A static factory class for tree view expand/collapse animations
*
* @constructor
*/</pre>

<p>YAHOO.widget.TVAnim = function() {</p>

<pre>return {
    /**
     * Constant for the fade in animation
     * 
     * @type string
     */
    FADE_IN: &quot;TVFadeIn&quot;,

    /**
     * Constant for the fade out animation
     * 
     * @type string
     */
    FADE_OUT: &quot;TVFadeOut&quot;,

    /**
     * Returns a ygAnim instance of the given type
     *
     * @param type {string} the type of animation
     * @param el {HTMLElement} the element to element (probably the children div)
     * @param callback {function} function to invoke when the animation is done.
     * @return {YAHOO.util.Animation} the animation instance
     */
    getAnim: function(type, el, callback) {
        if (YAHOO.widget[type]) {
            return new YAHOO.widget[type](el, callback);
        } else {
            return null;
        }
    },

    /**
     * Returns true if the specified animation class is available
     *
     * @param type {string} the type of animation
     * @return {boolean} true if valid, false if not
     */
    isValid: function(type) {
        return (YAHOO.widget[type]);
    }
};</pre>

<p>} ();</p>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* A 1/2 second fade-in animation.
*
* @constructor
* @param el {HTMLElement} the element to animate
* @param callback {function} function to invoke when the animation is finished
*/</pre>

<p>YAHOO.widget.TVFadeIn = function(el, callback) {</p>

<pre>   /**
    * The element to animate
* @type HTMLElement
    */
   this.el = el;

   /**
    * the callback to invoke when the animation is complete
    *
    * @type function
    */
   this.callback = callback;

   /**
    * @private
    */</pre>

<p>};</p>

<p>/**</p>

<pre>* Performs the animation
*/</pre>

<p>YAHOO.widget.TVFadeIn.prototype = {</p>

<pre>animate: function() {
    var tvanim = this;

    var s = this.el.style;
    s.opacity = 0.1;
    s.filter = &quot;alpha(opacity=10)&quot;;
    s.display = &quot;&quot;;

    // var dur = ( navigator.userAgent.match(/msie/gi) ) ? 0.05 : 0.4;
    var dur = 0.4; 
    // var a = new ygAnim_Fade(this.el, dur, 1);
    // a.setStart(0.1);
    // a.onComplete = function() { tvanim.onComplete(); };

    // var a = new YAHOO.util.Anim(this.el, &#39;opacity&#39;, 0.1, 1);
    var a = new YAHOO.util.Anim(this.el, {opacity: {from: 0.1, to: 1, unit:&quot;&quot;}}, dur);
    a.onComplete.subscribe( function() { tvanim.onComplete(); } );
    a.animate();
},

/**
 * Clean up and invoke callback
 */
onComplete: function() {
    this.callback();
}</pre>

<p>};</p>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>/**</p>

<pre>* A 1/2 second fade out animation.
*
* @constructor
* @param el {HTMLElement} the element to animate
* @param callback {Function} function to invoke when the animation is finished
*/</pre>

<p>YAHOO.widget.TVFadeOut = function(el, callback) {</p>

<pre>   /**
    * The element to animate
* @type HTMLElement
    */
   this.el = el;

   /**
    * the callback to invoke when the animation is complete
    *
    * @type function
    */
   this.callback = callback;

   /**
    * @private
    */</pre>

<p>};</p>

<p>/**</p>

<pre>* Performs the animation
*/</pre>

<p>YAHOO.widget.TVFadeOut.prototype = {</p>

<pre>animate: function() {
    var tvanim = this;
    // var dur = ( navigator.userAgent.match(/msie/gi) ) ? 0.05 : 0.4;
    var dur = 0.4;
    // var a = new ygAnim_Fade(this.el, dur, 0.1);
    // a.onComplete = function() { tvanim.onComplete(); };

    // var a = new YAHOO.util.Anim(this.el, &#39;opacity&#39;, 1, 0.1);
    var a = new YAHOO.util.Anim(this.el, {opacity: {from: 1, to: 0.1, unit:&quot;&quot;}}, dur);
    a.onComplete.subscribe( function() { tvanim.onComplete(); } );
    a.animate();
},

/**
 * Clean up and invoke callback
 */
onComplete: function() {
    var s = this.el.style;
    s.display = &quot;none&quot;;
    // s.opacity = 1;
    s.filter = &quot;alpha(opacity=100)&quot;;
    this.callback();
}</pre>

<p>};</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.3.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

