<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>event.js - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
  var index_rel_prefix = "../../";
</script>

<script src="../../js/navigation.js" defer></script>
<script src="../../js/search.js" defer></script>
<script src="../../js/search_index.js" defer></script>
<script src="../../js/searcher.js" defer></script>
<script src="../../js/darkfish.js" defer></script>

<link href="../../css/fonts.css" rel="stylesheet">
<link href="../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../h2d/build_xml.html">build.xml</a>
    <li><a href="../../h2d/catalog_xml.html">catalog.xml</a>
    <li><a href="../../h2d/dtd/xhtml-lat1_ent.html">xhtml-lat1.ent</a>
    <li><a href="../../h2d/dtd/xhtml-special_ent.html">xhtml-special.ent</a>
    <li><a href="../../h2d/dtd/xhtml-symbol_ent.html">xhtml-symbol.ent</a>
    <li><a href="../../h2d/dtd/xhtml1-frameset_dtd.html">xhtml1-frameset.dtd</a>
    <li><a href="../../h2d/dtd/xhtml1-strict_dtd.html">xhtml1-strict.dtd</a>
    <li><a href="../../h2d/dtd/xhtml1-transitional_dtd.html">xhtml1-transitional.dtd</a>
    <li><a href="../../h2d/h2d_xsl.html">h2d.xsl</a>
    <li><a href="../../h2d/plugin_xml.html">plugin.xml</a>
    <li><a href="../../h2d/preprocess_xsl.html">preprocess.xsl</a>
    <li><a href="../../h2d/samples/concept_html.html">concept.html</a>
    <li><a href="../../h2d/samples/content_html.html">content.html</a>
    <li><a href="../../h2d/samples/reference_html.html">reference.html</a>
    <li><a href="../../h2d/samples/task_html.html">task.html</a>
    <li><a href="../../h2d/samples/topic_html.html">topic.html</a>
    <li><a href="../../log_txt.html">log</a>
    <li><a href="../../public/Test3_sh.html">Test3.sh</a>
    <li><a href="../../public/about_html.html">about.html</a>
    <li><a href="../../public/dtest_html.html">dtest.html</a>
    <li><a href="../../public/foo_html.html">foo.html</a>
    <li><a href="../../public/help_html.html">help.html</a>
    <li><a href="../../public/htm/Great_silly_movie_htm.html">Great_silly_movie.htm</a>
    <li><a href="../../public/htm/Movies_stepb_htm.html">Movies_stepb.htm</a>
    <li><a href="../../public/htm/athlete_htm.html">athlete.htm</a>
    <li><a href="../../public/htm/athlete_chase_htm.html">athlete_chase.htm</a>
    <li><a href="../../public/htm/athlete_jrol_htm.html">athlete_jrol.htm</a>
    <li><a href="../../public/htm/baseball_htm.html">baseball.htm</a>
    <li><a href="../../public/htm/baseball_schmidt_htm.html">baseball_schmidt.htm</a>
    <li><a href="../../public/htm/baseball_schmidt_md_htm.html">baseball_schmidt_md.htm</a>
    <li><a href="../../public/htm/bookmap_htm.html">bookmap.htm</a>
    <li><a href="../../public/htm/cm_htm.html">cm.htm</a>
    <li><a href="../../public/htm/cm_DITA_OT_htm.html">cm_DITA_OT.htm</a>
    <li><a href="../../public/htm/cm_TE_htm.html">cm_TE.htm</a>
    <li><a href="../../public/htm/cm_bookmap_html_htm.html">cm_bookmap_html.htm</a>
    <li><a href="../../public/htm/cm_create_entries_htm.html">cm_create_entries.htm</a>
    <li><a href="../../public/htm/cm_create_entries_md_htm.html">cm_create_entries_md.htm</a>
    <li><a href="../../public/htm/cm_create_entry_md_htm.html">cm_create_entry_md.htm</a>
    <li><a href="../../public/htm/cm_create_form_htm.html">cm_create_form.htm</a>
    <li><a href="../../public/htm/cm_create_map_html_htm.html">cm_create_map_html.htm</a>
    <li><a href="../../public/htm/cm_create_map_md_htm.html">cm_create_map_md.htm</a>
    <li><a href="../../public/htm/cm_create_maps_htm.html">cm_create_maps.htm</a>
    <li><a href="../../public/htm/cm_datamapper_htm.html">cm_datamapper.htm</a>
    <li><a href="../../public/htm/cm_display_set_of_data_htm.html">cm_display_set_of_data.htm</a>
    <li><a href="../../public/htm/cm_feature_htm.html">cm_feature.htm</a>
    <li><a href="../../public/htm/cm_html_snip_htm.html">cm_html_snip.htm</a>
    <li><a href="../../public/htm/cm_install_htm.html">cm_install.htm</a>
    <li><a href="../../public/htm/cm_intro_htm.html">cm_intro.htm</a>
    <li><a href="../../public/htm/cm_md_snip_htm.html">cm_md_snip.htm</a>
    <li><a href="../../public/htm/cm_required_software_htm.html">cm_required_software.htm</a>
    <li><a href="../../public/htm/cm_ruby_htm.html">cm_ruby.htm</a>
    <li><a href="../../public/htm/cm_run_dita_3_0_htm.html">cm_run_dita_3_0.htm</a>
    <li><a href="../../public/htm/cm_run_swcms_htm.html">cm_run_swcms.htm</a>
    <li><a href="../../public/htm/cm_set_variables_htm.html">cm_set_variables.htm</a>
    <li><a href="../../public/htm/cm_setting_menus_htm.html">cm_setting_menus.htm</a>
    <li><a href="../../public/htm/cm_setup_htm.html">cm_setup.htm</a>
    <li><a href="../../public/htm/cm_sinatra_htm.html">cm_sinatra.htm</a>
    <li><a href="../../public/htm/images_htm.html">images.htm</a>
    <li><a href="../../public/htm/images_Daffodil001_htm.html">images_Daffodil001.htm</a>
    <li><a href="../../public/htm/images_chase_htm.html">images_chase.htm</a>
    <li><a href="../../public/htm/images_cindy_htm.html">images_cindy.htm</a>
    <li><a href="../../public/htm/images_home_htm.html">images_home.htm</a>
    <li><a href="../../public/htm/images_jimmy_rollins_htm.html">images_jimmy_rollins.htm</a>
    <li><a href="../../public/htm/images_step_bros_htm.html">images_step_bros.htm</a>
    <li><a href="../../public/htm/images_test123_htm.html">images_test123.htm</a>
    <li><a href="../../public/htm/misc_htm.html">misc.htm</a>
    <li><a href="../../public/htm/misc_dita_app_htm.html">misc_dita_app.htm</a>
    <li><a href="../../public/htm/misc_event_htm.html">misc_event.htm</a>
    <li><a href="../../public/htm/misc_forward_htm.html">misc_forward.htm</a>
    <li><a href="../../public/htm/misc_h2d_htm.html">misc_h2d.htm</a>
    <li><a href="../../public/htm/misc_random_th_08_01_14_htm.html">misc_random_th_08_01_14.htm</a>
    <li><a href="../../public/htm/misc_run_ant_htm.html">misc_run_ant.htm</a>
    <li><a href="../../public/htm/movies_htm.html">movies.htm</a>
    <li><a href="../../public/htm/movies_old_school_htm.html">movies_old_school.htm</a>
    <li><a href="../../public/htm/recent_movies_htm.html">recent_movies.htm</a>
    <li><a href="../../public/htm/recent_movies__htm.html">recent_movies_.htm</a>
    <li><a href="../../public/htm/recent_movies_her_htm.html">recent_movies_her.htm</a>
    <li><a href="../../public/htm/recent_movies_mudd_htm.html">recent_movies_mudd.htm</a>
    <li><a href="../../public/htm/recent_movies_paranoia_htm.html">recent_movies_paranoia.htm</a>
    <li><a href="../../public/htm/sports_events_htm.html">sports_events.htm</a>
    <li><a href="../../public/htm/sports_events__htm.html">sports_events_.htm</a>
    <li><a href="../../public/htm/sports_events_2001_htm.html">sports_events_2001.htm</a>
    <li><a href="../../public/htm/sports_events_2007_ditamap.html">sports_events_2007.ditamap</a>
    <li><a href="../../public/htm/sports_events_2007_htm.html">sports_events_2007.htm</a>
    <li><a href="../../public/htm/sports_events_2009_htm.html">sports_events_2009.htm</a>
    <li><a href="../../public/htm/sports_events_2010_htm.html">sports_events_2010.htm</a>
    <li><a href="../../public/htm/sports_events_2011_htm.html">sports_events_2011.htm</a>
    <li><a href="../../public/htm/sports_events_2013_htm.html">sports_events_2013.htm</a>
    <li><a href="../../public/htm/sports_events_2014_htm.html">sports_events_2014.htm</a>
    <li><a href="../../public/htm/sports_events_2018_htm.html">sports_events_2018.htm</a>
    <li><a href="../../public/htm/table_test_htm.html">table_test.htm</a>
    <li><a href="../../public/htm/test_htm.html">test.htm</a>
    <li><a href="../../public/htm/topic_map_ditamap.html">topic_map.ditamap</a>
    <li><a href="../../public/htm/topic_map_htm.html">topic_map.htm</a>
    <li><a href="../../public/htm/topic_map_athletes_ditamap.html">topic_map_athletes.ditamap</a>
    <li><a href="../../public/htm/topic_map_cms_htm.html">topic_map_cms.htm</a>
    <li><a href="../../public/htm/topic_map_test_htm.html">topic_map_test.htm</a>
    <li><a href="../../public/htm/topic_map_test_1_ditamap.html">topic_map_test_1.ditamap</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/demo/demo_css.html">demo.css</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/demo/demo_html.html">demo.html</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/jquery-te-1_4_0_css.html">jquery-te-1.4.0.css</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/jquery-te-1_4_0_min_js.html">jquery-te-1.4.0.min.js</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/license/AUTHOR_txt.html">AUTHOR</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/license/MIT-LICENSE_txt.html">MIT-LICENSE</a>
    <li><a href="../../public/jQuery-TE_v_1_4_0/uncompressed/jquery-te-1_4_0_js.html">jquery-te-1.4.0.js</a>
    <li><a href="../../public/jss/JSS-masterindex_js.html">JSS-masterindex.js</a>
    <li><a href="../../public/jss/jss-front_html.html">jss-front.html</a>
    <li><a href="../../public/jss/jss-hittemplate_js.html">jss-hittemplate.js</a>
    <li><a href="../../public/jss/jss-index_html.html">jss-index.html</a>
    <li><a href="../../public/jss/jss-info_html.html">jss-info.html</a>
    <li><a href="../../public/jss/jss-search_html.html">jss-search.html</a>
    <li><a href="../../public/tocjs/commonltr_css.html">commonltr.css</a>
    <li><a href="../../public/tocjs/commonrtl_css.html">commonrtl.css</a>
    <li><a href="../../public/tocjs/css/check/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/code_css.html">code.css</a>
    <li><a href="../../public/tocjs/css/default/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/folders/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/local/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/menu/tree_css.html">tree.css</a>
    <li><a href="../../public/tocjs/css/screen_css.html">screen.css</a>
    <li><a href="../../public/tocjs/event_js.html">event.js</a>
    <li><a href="../../public/tocjs/tocnav_html.html">tocnav.html</a>
    <li><a href="../../public/tocjs/toctree_js.html">toctree.js</a>
    <li><a href="../../public/tocjs/topic_map_cms_html.html">topic_map_cms.html</a>
    <li><a href="../../public/tocjs/topics/cm_create_entries_html.html">cm_create_entries.html</a>
    <li><a href="../../public/tocjs/topics/cm_create_form_html.html">cm_create_form.html</a>
    <li><a href="../../public/tocjs/topics/cm_display_set_of_data_html.html">cm_display_set_of_data.html</a>
    <li><a href="../../public/tocjs/topics/cm_run_dita_3_0_html.html">cm_run_dita_3_0.html</a>
    <li><a href="../../public/tocjs/topics/cm_run_swcms_html.html">cm_run_swcms.html</a>
    <li><a href="../../public/tocjs/topics/cm_set_variables_html.html">cm_set_variables.html</a>
    <li><a href="../../public/tocjs/topics/cm_setup_html.html">cm_setup.html</a>
    <li><a href="../../public/tocjs/topics/cm_usage_html.html">cm_usage.html</a>
    <li><a href="../../public/tocjs/treeview_js.html">treeview.js</a>
    <li><a href="../../public/tocjs/yahoo_js.html">yahoo.js</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page public/tocjs/event.js">

<p>/* This file is part of the DITA Open Toolkit project.</p>

<p>See the accompanying LICENSE file for applicable license.</p>

<p>Copyright © 2006, Yahoo! Inc. All rights reserved.                                                                                                 </p>

<p>Code licensed under the BSD License:                                                                                                                 </p>

<p><a href="http://developer.yahoo.net/yui/license.txt">developer.yahoo.net/yui/license.txt</a>                                                                                                           </p>

<p>version: 0.10.0                                                                                                                                      </p>

<p>*/ </p>

<p>/**</p>

<pre>* The CustomEvent class lets you define events for your application
* that can be subscribed to by one or more independent component.
*
* @param {String} type The type of event, which is passed to the callback
*                 when the event fires
* @param {Object} oScope The context the event will fire from.  &quot;this&quot; will
*                 refer to this object in the callback.  Default value: 
*                 the window object.  The listener can override this.
* @constructor
*/</pre>

<p>YAHOO.util.CustomEvent = function(type, oScope) {</p>

<pre>/**
 * The type of event, returned to subscribers when the event fires
 * @type string
 */
this.type = type;

/**
 * The scope the the event will fire from by default.  Defaults to the window 
 * obj
 * @type object
 */
this.scope = oScope || window;

/**
 * The subscribers to this event
 * @type Subscriber[]
 */
this.subscribers = [];

// Register with the event utility for automatic cleanup.  Made optional
// so that CustomEvent can be used independently of pe.event
if (YAHOO.util.Event) { 
    YAHOO.util.Event.regCE(this);
}</pre>

<p>};</p>

<p>YAHOO.util.CustomEvent.prototype = {</p>

<pre>/**
 * Subscribes the caller to this event
 * @param {Function} fn       The function to execute
 * @param {Object}   obj      An object to be passed along when the event fires
 * @param {boolean}  bOverride If true, the obj passed in becomes the execution
 *                            scope of the listener
 */
subscribe: function(fn, obj, bOverride) {
    this.subscribers.push( new YAHOO.util.Subscriber(fn, obj, bOverride) );
},

/**
 * Unsubscribes the caller from this event
 * @param {Function} fn  The function to execute
 * @param {Object}   obj An object to be passed along when the event fires
 * @return {boolean} True if the subscriber was found and detached.
 */
unsubscribe: function(fn, obj) {
    var found = false;
    for (var i=0, len=this.subscribers.length; i&lt;len; ++i) {
        var s = this.subscribers[i];
        if (s &amp;&amp; s.contains(fn, obj)) {
            this._delete(i);
            found = true;
        }
    }

    return found;
},

/**
 * Notifies the subscribers.  The callback functions will be executed
 * from the scope specified when the event was created, and with the following
 * parameters:
 *   &lt;pre&gt;
 *   - The type of event
 *   - All of the arguments fire() was executed with as an array
 *   - The custom object (if any) that was passed into the subscribe() method
 *   &lt;/pre&gt;
 *   
 * @param {Array} an arbitrary set of parameters to pass to the handler
 */
fire: function() {
    for (var i=0, len=this.subscribers.length; i&lt;len; ++i) {
        var s = this.subscribers[i];
        if (s) {
            var scope = (s.override) ? s.obj : this.scope;
            s.fn.call(scope, this.type, arguments, s.obj);
        }
    }
},

/**
 * Removes all listeners
 */
unsubscribeAll: function() {
    for (var i=0, len=this.subscribers.length; i&lt;len; ++i) {
        this._delete(i);
    }
},

/**
 * @private
 */
_delete: function(index) {
    var s = this.subscribers[index];
    if (s) {
        delete s.fn;
        delete s.obj;
    }

    delete this.subscribers[index];
}</pre>

<p>};</p>

<p>/////////////////////////////////////////////////////////////////////</p>

<p>/**</p>

<pre>* @class Stores the subscriber information to be used when the event fires.
* @param {Function} fn       The function to execute
* @param {Object}   obj      An object to be passed along when the event fires
* @param {boolean}  bOverride If true, the obj passed in becomes the execution
*                            scope of the listener
* @constructor
*/</pre>

<p>YAHOO.util.Subscriber = function(fn, obj, bOverride) {</p>

<pre>/**
 * The callback that will be execute when the event fires
 * @type function
 */
this.fn = fn;

/**
 * An optional custom object that will passed to the callback when
 * the event fires
 * @type object
 */
this.obj = obj || null;

/**
 * The default execution scope for the event listener is defined when the
 * event is created (usually the object which contains the event).
 * By setting override to true, the execution scope becomes the custom
 * object passed in by the subscriber
 * @type boolean
 */
this.override = (bOverride);</pre>

<p>};</p>

<p>/**</p>

<pre>* Returns true if the fn and obj match this objects properties.
* Used by the unsubscribe method to match the right subscriber.
*
* @param {Function} fn the function to execute
* @param {Object} obj an object to be passed along when the event fires
* @return {boolean} true if the supplied arguments match this 
*                   subscriber&#39;s signature.
*/</pre>

<p>YAHOO.util.Subscriber.prototype.contains = function(fn, obj) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">fn</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">fn</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">obj</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">obj</span>);
</pre>

<p>};</p>

<p>/* Copyright © 2006 Yahoo! Inc. All rights reserved. */</p>

<p>// Only load this library once.  If it is loaded a second time, existing // events cannot be detached. if (!YAHOO.util.Event) {</p>

<p>/**</p>

<pre>* @class
* The event utility provides functions to add and remove event listeners,
* event cleansing.  It also tries to automatically remove listeners it
* registers during the unload event.
* @constructor
*/
   YAHOO.util.Event = function() {

       /**
        * True after the onload event has fired
        * @type boolean
        * @private
        */
       var loadComplete =  false;

       /**
        * Cache of wrapped listeners
        * @type array
        * @private
        */
       var listeners = [];

       /**
        * Listeners that will be attached during the onload event
        * @type array
        * @private
        */
       var delayedListeners = [];

       /**
        * User-defined unload function that will be fired before all events
        * are detached
        * @type array
        * @private
        */
       var unloadListeners = [];

       /**
        * Cache of the custom events that have been defined.  Used for
        * automatic cleanup
        * @type array
        * @private
        */
       var customEvents = [];

       /**
        * Cache of DOM0 event handlers to work around issues with DOM2 events
        * in Safari
        * @private
        */
       var legacyEvents = [];

       /**
        * Listener stack for DOM0 events
        * @private
        */
       var legacyHandlers = [];

       /**
        * The number of times to poll after window.onload.  This number is
        * increased if additional late-bound handlers are requested after
        * the page load.
        * @private
        */
       var retryCount = 0;

       /**
        * onAvailable listeners
        * @private
        */
       var onAvailStack = [];

       /**
        * Lookup table for legacy events
        * @private
        */
       var legacyMap = [];

       /**
        * Counter for auto id generation
        * @private
        */
       var counter = 0;

       return { // PREPROCESS

           /**
            * The number of times we should look for elements that are not
            * in the DOM at the time the event is requested after the document
            * has been loaded.  The default is 200@50 ms, so it will poll
            * for 10 seconds or until all outstanding handlers are bound
            * (whichever comes first).
            * @type int
            */
           POLL_RETRYS: 200,

           /**
            * The poll interval in milliseconds
            * @type int
            */
           POLL_INTERVAL: 50,

           /**
            * Element to bind, int constant
            * @type int
            */
           EL: 0,

           /**
            * Type of event, int constant
            * @type int
            */
           TYPE: 1,

           /**
            * Function to execute, int constant
            * @type int
            */
           FN: 2,

           /**
            * Function wrapped for scope correction and cleanup, int constant
            * @type int
            */
           WFN: 3,

           /**
            * Object passed in by the user that will be returned as a 
            * parameter to the callback, int constant
            * @type int
            */
           SCOPE: 3,

           /**
            * Adjusted scope, either the element we are registering the event
            * on or the custom object passed in by the listener, int constant
            * @type int
            */
           ADJ_SCOPE: 4,

           /**
            * Safari detection is necessary to work around the preventDefault
            * bug that makes it so you can&#39;t cancel a href click from the 
            * handler.  There is not a capabilities check we can use here.
            * @private
            */
           isSafari: (/Safari|Konqueror|KHTML/gi).test(navigator.userAgent),

           /**
            * IE detection needed to properly calculate pageX and pageY.  
            * capabilities checking didn&#39;t seem to work because another 
            * browser that does not provide the properties have the values 
            * calculated in a different manner than IE.
            * @private
            */
           isIE: (!this.isSafari &amp;&amp; !navigator.userAgent.match(/opera/gi) &amp;&amp; 
                   navigator.userAgent.match(/msie/gi)),

           /**
            * @private
            */
           addDelayedListener: function(el, sType, fn, oScope, bOverride) {
               delayedListeners[delayedListeners.length] =
                   [el, sType, fn, oScope, bOverride];

               // If this happens after the inital page load, we need to
               // reset the poll counter so that we continue to search for
               // the element for a fixed period of time.
               if (loadComplete) {
                   retryCount = this.POLL_RETRYS;
                   this.startTimeout(0);
                   // this._tryPreloadAttach();
               }
           },

           /**
            * @private
            */
           startTimeout: function(interval) {
               var i = (interval || interval === 0) ? interval : this.POLL_INTERVAL;
               var self = this;
               var callback = function() { self._tryPreloadAttach(); };
               this.timeout = setTimeout(callback, i);
           },

           /**
            * Executes the supplied callback when the item with the supplied
            * id is found.  This is meant to be used to execute behavior as
            * soon as possible as the page loads.  If you use this after the
            * initial page load it will poll for a fixed time for the element.
            * The number of times it will poll and the frequency are
            * configurable.  By default it will poll for 10 seconds.
            * @param {string} p_id the id of the element to look for.
            * @param {function} p_fn what to execute when the element is found.
            * @param {object} p_obj an optional object to be passed back as
            * a parameter to p_fn.
            * @param {boolean} p_override If set to true, p_fn will execute
            * in the scope of p_obj
            *
            */
           onAvailable: function(p_id, p_fn, p_obj, p_override) {
               onAvailStack.push( { id:       p_id, 
                                    fn:       p_fn, 
                                    obj:      p_obj, 
                                    override: p_override } );

               retryCount = this.POLL_RETRYS;
               this.startTimeout(0);
               // this._tryPreloadAttach();
           },

           /**
            * Appends an event handler
            *
            * @param {Object}   el        The html element to assign the 
            *                             event to
            * @param {String}   sType     The type of event to append
            * @param {Function} fn        The method the event invokes
            * @param {Object}   oScope    An arbitrary object that will be 
            *                             passed as a parameter to the handler
            * @param {boolean}  bOverride If true, the obj passed in becomes
            *                             the execution scope of the listener
            * @return {boolean} True if the action was successful or defered,
            *                        false if one or more of the elements 
            *                        could not have the event bound to it.
            */
           addListener: function(el, sType, fn, oScope, bOverride) {

               if (!fn || !fn.call) {
                   return false;
               }

               // The el argument can be an array of elements or element ids.
               if ( this._isValidCollection(el)) {
                   var ok = true;
                   for (var i=0,len=el.length; i&lt;len; ++i) {
                       ok = ( this.on(el[i], 
                                      sType, 
                                      fn, 
                                      oScope, 
                                      bOverride) &amp;&amp; ok );
                   }
                   return ok;

               } else if (typeof el == &quot;string&quot;) {
                   var oEl = this.getEl(el);
                   // If the el argument is a string, we assume it is 
                   // actually the id of the element.  If the page is loaded
                   // we convert el to the actual element, otherwise we 
                   // defer attaching the event until onload event fires

                   // check to see if we need to delay hooking up the event 
                   // until after the page loads.
                   if (loadComplete &amp;&amp; oEl) {
                       el = oEl;
                   } else {
                       // defer adding the event until onload fires
                       this.addDelayedListener(el, 
                                               sType, 
                                               fn, 
                                               oScope, 
                                               bOverride);

                       return true;
                   }
               }

               // Element should be an html element or an array if we get 
               // here.
               if (!el) {
                   return false;
               }

               // we need to make sure we fire registered unload events 
               // prior to automatically unhooking them.  So we hang on to 
               // these instead of attaching them to the window and fire the
               // handles explicitly during our one unload event.
               if (&quot;unload&quot; == sType &amp;&amp; oScope !== this) {
                   unloadListeners[unloadListeners.length] =
                           [el, sType, fn, oScope, bOverride];
                   return true;
               }

               // if the user chooses to override the scope, we use the custom
               // object passed in, otherwise the executing scope will be the
               // HTML element that the event is registered on
               var scope = (bOverride) ? oScope : el;

               // wrap the function so we can return the oScope object when
               // the event fires;
               var wrappedFn = function(e) {
                       return fn.call(scope, YAHOO.util.Event.getEvent(e), 
                               oScope);
                   };

               var li = [el, sType, fn, wrappedFn, scope];
               var index = listeners.length;
               // cache the listener so we can try to automatically unload
               listeners[index] = li;

               if (this.useLegacyEvent(el, sType)) {
                   var legacyIndex = this.getLegacyIndex(el, sType);
                   if (legacyIndex == -1) {

                       legacyIndex = legacyEvents.length;
                       legacyMap[el.id + sType] = legacyIndex;

                       // cache the signature for the DOM0 event, and 
                       // include the existing handler for the event, if any
                       legacyEvents[legacyIndex] = 
                           [el, sType, el[&quot;on&quot; + sType]];
                       legacyHandlers[legacyIndex] = [];

                       el[&quot;on&quot; + sType] = 
                           function(e) {
                               YAHOO.util.Event.fireLegacyEvent(
                                   YAHOO.util.Event.getEvent(e), legacyIndex);
                           };
                   }

                   // add a reference to the wrapped listener to our custom
                   // stack of events
                   legacyHandlers[legacyIndex].push(index);

               // DOM2 Event model
               } else if (el.addEventListener) {
                   el.addEventListener(sType, wrappedFn, false);
               // Internet Explorer abstraction
               } else if (el.attachEvent) {
                   el.attachEvent(&quot;on&quot; + sType, wrappedFn);
               }

               return true;

           },

           /**
            * Shorthand for YAHOO.util.Event.addListener
            * @type function
            */
           // on: this.addListener,

           /**
            * When using legacy events, the handler is routed to this object
            * so we can fire our custom listener stack.
            * @private
            */
           fireLegacyEvent: function(e, legacyIndex) {
               var ok = true;

               var le = legacyHandlers[legacyIndex];
               for (var i=0,len=le.length; i&lt;len; ++i) {
                   var index = le[i];
                   if (index) {
                       var li = listeners[index];
                       if ( li &amp;&amp; li[this.WFN] ) {
                           var scope = li[this.ADJ_SCOPE];
                           var ret = li[this.WFN].call(scope, e);
                           ok = (ok &amp;&amp; ret);
                       } else {
                           // This listener was removed, so delete it from
                           // the array
                           delete le[i];
                       }
                   }
               }

               return ok;
           },

           /**
            * Returns the legacy event index that matches the supplied 
            * signature
            * @private
            */
           getLegacyIndex: function(el, sType) {
               /*
               for (var i=0,len=legacyEvents.length; i&lt;len; ++i) {
                   var le = legacyEvents[i];
                   if (le &amp;&amp; le[0] === el &amp;&amp; le[1] === sType) {
                       return i;
                   }
               }
               return -1;
               */

               var key = this.generateId(el) + sType;
               if (typeof legacyMap[key] == &quot;undefined&quot;) { 
                   return -1;
               } else {
                   return legacyMap[key];
               }

           },

           /**
            * Logic that determines when we should automatically use legacy
            * events instead of DOM2 events.
            * @private
            */
           useLegacyEvent: function(el, sType) {

               if (!el.addEventListener &amp;&amp; !el.attachEvent) {
                   return true;
               } else if (this.isSafari) {
                   if (&quot;click&quot; == sType || &quot;dblclick&quot; == sType) {
                       return true;
                   }
               }

               return false;
           },

           /**
            * Removes an event handler
            *
            * @param {Object} el the html element or the id of the element to 
            * assign the event to.
            * @param {String} sType the type of event to remove
            * @param {Function} fn the method the event invokes
            * @return {boolean} true if the unbind was successful, false 
            * otherwise
            */
           removeListener: function(el, sType, fn, index) {

               if (!fn || !fn.call) {
                   return false;
               }

               // The el argument can be a string
               if (typeof el == &quot;string&quot;) {
                   el = this.getEl(el);
               // The el argument can be an array of elements or element ids.
               } else if ( this._isValidCollection(el)) {
                   var ok = true;
                   for (var i=0,len=el.length; i&lt;len; ++i) {
                       ok = ( this.removeListener(el[i], sType, fn) &amp;&amp; ok );
                   }
                   return ok;
               }

               if (&quot;unload&quot; == sType) {

                   for (i=0, len=unloadListeners.length; i&lt;len; i++) {
                       var li = unloadListeners[i];
                       if (li &amp;&amp; 
                           li[0] == el &amp;&amp; 
                           li[1] == sType &amp;&amp; 
                           li[2] == fn) {
                               delete unloadListeners[i];
                               return true;
                       }
                   }

                   return false;
               }

               var cacheItem = null;

               if (&quot;undefined&quot; == typeof index) {
                   index = this._getCacheIndex(el, sType, fn);
               }

               if (index &gt;= 0) {
                   cacheItem = listeners[index];
               }

               if (!el || !cacheItem) {
                   return false;
               }

               if (el.removeEventListener) {
                   el.removeEventListener(sType, cacheItem[this.WFN], false);
               } else if (el.detachEvent) {
                   el.detachEvent(&quot;on&quot; + sType, cacheItem[this.WFN]);
               }

               // removed the wrapped handler
               delete listeners[index][this.WFN];
               delete listeners[index][this.FN];
               delete listeners[index];

               return true;

           },

           /**
            * Returns the event&#39;s target element
            * @param {Event} ev the event
            * @param {boolean} resolveTextNode when set to true the target&#39;s
            *                  parent will be returned if the target is a 
            *                  text node
            * @return {HTMLElement} the event&#39;s target
            */
           getTarget: function(ev, resolveTextNode) {
               var t = ev.target || ev.srcElement;

               if (resolveTextNode &amp;&amp; t &amp;&amp; &quot;#text&quot; == t.nodeName) {
                   return t.parentNode;
               } else {
                   return t;
               }
           },

           /**
            * Returns the event&#39;s pageX
            * @param {Event} ev the event
            * @return {int} the event&#39;s pageX
            */
           getPageX: function(ev) {
               var x = ev.pageX;
               if (!x &amp;&amp; 0 !== x) {
                   x = ev.clientX || 0;

                   if ( this.isIE ) {
                       x += this._getScrollLeft();
                   }
               }

               return x;
           },

           /**
            * Returns the event&#39;s pageY
            * @param {Event} ev the event
            * @return {int} the event&#39;s pageY
            */
           getPageY: function(ev) {
               var y = ev.pageY;
               if (!y &amp;&amp; 0 !== y) {
                   y = ev.clientY || 0;

                   if ( this.isIE ) {
                       y += this._getScrollTop();
                   }
               }

               return y;
           },

           /**
            * Returns the pageX and pageY properties as an indexed array.
            * @type int[]
            */
           getXY: function(ev) {
               return [this.getPageX(ev), this.getPageY(ev)];
           },

           /**
            * Returns the event&#39;s related target 
            * @param {Event} ev the event
            * @return {HTMLElement} the event&#39;s relatedTarget
            */
           getRelatedTarget: function(ev) {
               var t = ev.relatedTarget;
               if (!t) {
                   if (ev.type == &quot;mouseout&quot;) {
                       t = ev.toElement;
                   } else if (ev.type == &quot;mouseover&quot;) {
                       t = ev.fromElement;
                   }
               }

               return t;
           },

           /**
            * Returns the time of the event.  If the time is not included, the
            * event is modified using the current time.
            * @param {Event} ev the event
            * @return {Date} the time of the event
            */
           getTime: function(ev) {
               if (!ev.time) {
                   var t = new Date().getTime();
                   try {
                       ev.time = t;
                   } catch(e) { 
                       // can&#39;t set the time property  
                       return t;
                   }
               }

               return ev.time;
           },

           /**
            * Convenience method for stopPropagation + preventDefault
            * @param {Event} ev the event
            */
           stopEvent: function(ev) {
               this.stopPropagation(ev);
               this.preventDefault(ev);
           },

           /**
            * Stops event propagation
            * @param {Event} ev the event
            */
           stopPropagation: function(ev) {
               if (ev.stopPropagation) {
                   ev.stopPropagation();
               } else {
                   ev.cancelBubble = true;
               }
           },

           /**
            * Prevents the default behavior of the event
            * @param {Event} ev the event
            */
           preventDefault: function(ev) {
               if (ev.preventDefault) {
                   ev.preventDefault();
               } else {
                   ev.returnValue = false;
               }
           },

           /**
            * Finds the event in the window object, the caller&#39;s arguments, or
            * in the arguments of another method in the callstack.  This is
            * executed automatically for events registered through the event
            * manager, so the implementer should not normally need to execute
            * this function at all.
            * @param {Event} the event parameter from the handler
            * @return {Event} the event 
            */
           getEvent: function(e) {
               var ev = e || window.event;

               if (!ev) {
                   var c = this.getEvent.caller;
                   while (c) {
                       ev = c.arguments[0];
                       if (ev &amp;&amp; Event == ev.constructor) {
                           break;
                       }
                       c = c.caller;
                   }
               }

               return ev;
           },

           /**
            * Returns the charcode for an event
            * @param {Event} ev the event
            * @return {int} the event&#39;s charCode
            */
           getCharCode: function(ev) {
               return ev.charCode || ((ev.type == &quot;keypress&quot;) ? ev.keyCode : 0);
           },

           /**
            * @private
            * Locating the saved event handler data by function ref
            */
           _getCacheIndex: function(el, sType, fn) {
               for (var i=0,len=listeners.length; i&lt;len; ++i) {
                   var li = listeners[i];
                   if ( li                 &amp;&amp; 
                        li[this.FN] == fn  &amp;&amp; 
                        li[this.EL] == el  &amp;&amp; 
                        li[this.TYPE] == sType ) {
                       return i;
                   }
               }

               return -1;
           },

           /**
            * Generates an unique ID for the element if it does not already 
            * have one.
            * @param el the element
            * @return {string} the id of the element
            */
           generateId: function(el) {
               var id = el.id;

               if (!id) {
                   id = &quot;yuievtautoid-&quot; + (counter++);
                   el.id = id;
               }

               return id;
           },

           /**
            * We want to be able to use getElementsByTagName as a collection
            * to attach a group of events to.  Unfortunately, different 
            * browsers return different types of collections.  This function
            * tests to determine if the object is array-like.  It will also 
            * fail if the object is an array, but is empty.
            * @param o the object to test
            * @return {boolean} true if the object is array-like and populated
            * @private
            */
           _isValidCollection: function(o) {

               return ( o                    &amp;&amp; // o is something
                        o.length             &amp;&amp; // o is indexed
                        typeof o != &quot;string&quot; &amp;&amp; // o is not a string
                        !o.tagName           &amp;&amp; // o is not an HTML element
                        !o.alert             &amp;&amp; // o is not a window
                        typeof o[0] != &quot;undefined&quot; );

           },

           /**
            * @private
            * DOM element cache
            */
           elCache: {},

           /**
            * We cache elements bound by id because when the unload event 
            * fires, we can no longer use document.getElementById
            * @private
            */
           getEl: function(id) {
               return document.getElementById(id);
           },

           /**
            * Clears the element cache
            * @deprecated
            * @private
            */
           clearCache: function() { },

           /**
            * Called by CustomEvent instances to provide a handle to the 
            * event * that can be removed later on.  Should be package 
            * protected.
            * @private
            */
           regCE: function(ce) {
               customEvents.push(ce);
           },

           /**
            * @private
            * hook up any deferred listeners
            */
           _load: function(e) {
               loadComplete = true;
           },

           /**
            * Polling function that runs before the onload event fires, 
            * attempting * to attach to DOM Nodes as soon as they are 
            * available
            * @private
            */
           _tryPreloadAttach: function() {

               if (this.locked) {
                   return false;
               }

               this.locked = true;

               // keep trying until after the page is loaded.  We need to 
               // check the page load state prior to trying to bind the 
               // elements so that we can be certain all elements have been 
               // tested appropriately
               var tryAgain = !loadComplete;
               if (!tryAgain) {
                   tryAgain = (retryCount &gt; 0);
               }

               // Delayed listeners
               var stillDelayed = [];

               for (var i=0,len=delayedListeners.length; i&lt;len; ++i) {
                   var d = delayedListeners[i];
                   // There may be a race condition here, so we need to 
                   // verify the array element is usable.
                   if (d) {

                       // el will be null if document.getElementById did not
                       // work
                       var el = this.getEl(d[this.EL]);

                       if (el) {
                           this.on(el, d[this.TYPE], d[this.FN], 
                                   d[this.SCOPE], d[this.ADJ_SCOPE]);
                           delete delayedListeners[i];
                       } else {
                           stillDelayed.push(d);
                       }
                   }
               }

               delayedListeners = stillDelayed;

               // onAvailable
               notAvail = [];
               for (i=0,len=onAvailStack.length; i&lt;len ; ++i) {
                   var item = onAvailStack[i];
                   if (item) {
                       el = this.getEl(item.id);

                       if (el) {
                           var scope = (item.override) ? item.obj : el;
                           item.fn.call(scope, item.obj);
                           delete onAvailStack[i];
                       } else {
                           notAvail.push(item);
                       }
                   }
               }

               retryCount = (stillDelayed.length === 0 &amp;&amp; 
                                   notAvail.length === 0) ? 0 : retryCount - 1;

               if (tryAgain) {
                   this.startTimeout();
               }

               this.locked = false;

           },

           /**
            * Removes all listeners registered by pe.event.  Called 
            * automatically during the unload event.
            * @private
            */
           _unload: function(e, me) {
               for (var i=0,len=unloadListeners.length; i&lt;len; ++i) {
                   var l = unloadListeners[i];
                   if (l) {
                       var scope = (l[this.ADJ_SCOPE]) ? l[this.SCOPE]: window;
                       l[this.FN].call(scope, this.getEvent(e), l[this.SCOPE] );
                   }
               }

               if (listeners &amp;&amp; listeners.length &gt; 0) {
                   for (i=0,len=listeners.length; i&lt;len ; ++i) {
                       l = listeners[i];
                       if (l) {
                           this.removeListener(l[this.EL], l[this.TYPE], 
                                   l[this.FN], i);
                       }
                   }

                   this.clearCache();
               }

               for (i=0,len=customEvents.length; i&lt;len; ++i) {
                   customEvents[i].unsubscribeAll();
                   delete customEvents[i];
               }

               for (i=0,len=legacyEvents.length; i&lt;len; ++i) {
                   // dereference the element
                   delete legacyEvents[i][0];
                   // delete the array item
                   delete legacyEvents[i];
               }
           },

           /**
            * Returns scrollLeft
            * @private
            */
           _getScrollLeft: function() {
               return this._getScroll()[1];
           },

           /**
            * Returns scrollTop
            * @private
            */
           _getScrollTop: function() {
               return this._getScroll()[0];
           },

           /**
            * Returns the scrollTop and scrollLeft.  Used to calculate the 
            * pageX and pageY in Internet Explorer
            * @private
            */
           _getScroll: function() {
               var dd = document.documentElement; db = document.body;
               if (dd &amp;&amp; dd.scrollTop) {
                   return [dd.scrollTop, dd.scrollLeft];
               } else if (db) {
                   return [db.scrollTop, db.scrollLeft];
               } else {
                   return [0, 0];
               }
           }
       };
   } ();

   /**
    * @private
    */
   YAHOO.util.Event.on = YAHOO.util.Event.addListener;

   if (document &amp;&amp; document.body) {
       YAHOO.util.Event._load();
   } else {
       YAHOO.util.Event.on(window, &quot;load&quot;, YAHOO.util.Event._load, 
               YAHOO.util.Event, true);
   }

   YAHOO.util.Event.on(window, &quot;unload&quot;, YAHOO.util.Event._unload, 
               YAHOO.util.Event, true);

   YAHOO.util.Event._tryPreloadAttach();</pre>

<p>}</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.3.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

